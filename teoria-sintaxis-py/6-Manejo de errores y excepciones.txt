<<<SyntaxError>>>
el código no sigue las reglas de sintaxis de Python 
como olvidar dos puntos después de una declaración de función o un bucle.

def mi_funcion() # Falta los dos puntos
    print("Hola")

<<<NameError>>>
Ocurre cuando se hace referencia a una variable o función que no ha sido definida.

print(variable_no_definida)

<<<TypeError>>>
Ocurre cuando se realiza una operación con tipos de datos incompatibles, como intentar sumar un número y una cadena.

resultado = 5 + "10"


<<<IndexError>>>
Ocurre cuando se intenta acceder a un índice fuera del rango válido de una lista o secuencia.

lista = [1, 2, 3]
print(lista[3])  # El índice 3 está fuera del rango

<<<MANEJO DE EXCEPCIONES>>>
permite capturar y manejar errores de manera controlada utilizando las declaraciones

    <<<Try>>>
    contiene codigo que puede generar una ecepcion. si ocurre una Excepcion dentro del bloque try, el flujo de ejercucion se transfiere
    al bloque except correspondiente
    try:
        # Código que puede generar una excepción
        resultado = 10 / 0  # División por cero
        print(resultado)
    except ZeroDivisionError:
        print("Error: División por cero")

    <<<Except>>>
     especifica el tipo de excepción que se desea capturar y manejar. 
     Puedes tener múltiples bloques except para manejar diferentes tipos de excepciones.

     try:
        # Código que puede generar una excepción
        resultado = 10 / 0  # División por cero
        print(resultado)
    except ZeroDivisionError:
        print("Error: División por cero")
    except ValueError:
        print("Error: Valor inválido")

    <<<Finally>>>
    se ejecuta siempre, independientemente de si ocurrió una excepción o no. 
    Se utiliza comúnmente para realizar tareas de limpieza o liberación de recursos.

    try:
        # Código que puede generar una excepción
        archivo = open("archivo.txt", "r")
        # Realizar operaciones con el archivo
    except FileNotFoundError:
        print("Error: Archivo no encontrado")
    finally:
        archivo.close()  # Cerrar el archivo siempre, incluso si ocurre una excepción   

<<<EXCEPCIONES PERSONALIZADAS>>>
Para crear una excepción personalizada, debes crear una clase que herede de la clase base Exception o de una de sus subclases.

def funcion():
    # Código que puede generar una excepción personalizada
    if condicion:
        raise Exception("Descripción del error")

try:
    funcion()
except Exception as e:
    print(f"Error: {str(e)}")


se define una función llamada funcion(). 
Dentro de la función, se verifica una condición y, si se cumple, se genera una excepción utilizando la declaración raise. 
En lugar de crear una clase personalizada, se utiliza directamente la clase base Exception para generar la excepción.
Luego, se utiliza un bloque try-except para capturar y manejar la excepción. 
La variable e se utiliza para acceder a la descripción del error proporcionada al generar la excepción.
